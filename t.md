正则
算法
## 安全
常见的 web 安全及防范原理

> sql 注入原理

原理：通过把 SQL 命令插入到 web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。

防范：
    1. 不相信用户的输入，对用户输入进行校验，可以通过正则表达式，或限制长度，对单引号和双 ‘-’ 进行转换等。
    2. 不要使用动态拼装 SQL，可以使用参数化的 SQL 或直接使用存储过程进行数据查询存取。
    3. 不使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4. 不要把机密信息明文存放，加密或者hash掉密码和敏感的信息。

> XSS原理及防范

原理：XSS(cross-site scripting) 攻击指的是攻击者往 WEB 页面插入恶意的 `html` 标签或者 `javascript` 代码。
比如：攻击者在论坛放一个连接，骗取用户点击后，窃取 `cookie` 中用户的私密信息；或者放一个表单，当用户提交表单时候，却把信息传送到攻击者的服务器，而不是用户原本以为的信任站点。

防范：
- 代码层面对用户输入的地方和变量做检查校验，比如说长度，另外对 "<", ">", ";", ",", "'" 这些敏感字符做过滤；
其次任何内容写到页面之前都先做 `encode`, 避免不小心把 html tag 弄出来。（这个层面可以堵住超过一半的 XSS 攻击。

- 用户敏感信息不要放在 `cookie`

- 通过 `cookie` 和系统 `ip` 绑定来降低 `cookie` 泄漏后的危险。这样尽管攻击者得到 cookie 也没有多大价值。

- 如果站点不需要再浏览器端对 `cookie` 进行操作，可以在 `Set-Cookie` 末尾加上 `HttpOnly` 来防止 JS 代码直接获取 `cookie`

- 尽量使用 `POST` 来做表单提交。


> XSS 和 CSRF 有什么区别？

XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。
CSRF 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

完成一次 CSRF 攻击，受害者必须依次完成两个步骤：
    1. 登录受信任网站A，并在本地生产 Cookie
    2. 在不登出A的情况下，访问危险网站B

防范：
    服务端的方式有很多，但总体思想都是一致的：就是在客户端页面增加伪随机数。


## 作用域连的理解 (scope chain)
作用是 保证执行环境里（execution context）有权访问的 变量 和 函数 是有序的。
变量只能向上访问，到 window 对象为止。不能向下访问变量


## 创建 ajax 过程

## JS 垃圾回收


## 性能优化
代码层面
    避免使用通配符选择器
    避免选择器累赘使用
    避免使用 CSS 表达式 (使用好的 CSS 架构 ITCSS 组件化)
    用 `hash-table` 来优化查找
    少用全局变量
    用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 JS 性能
    用 setTimeout 来避免页面失去响应
    缓存 DOM 节点查找的结果
    避免使用 with (with 会创建自己的作用域，会增加作用域链长度)
    多个变量合并声明 (JS 在处理单条复杂语句性能会比处理多条简单语句性能好)
    避免图片和 iFrame 的空 src (空 src ="" 会重新加载当前页面，影响速度和效率)
    尽量避免在 HTML 标签中写 style 属性
    尽量使用 CSS3 动画代替 JS 动画，开启硬件加速 => translateZ() / translate3d()
    适当使用 touch 事件 代替 click 事件
    避免使用 css3 渐变阴影效果
    不滥用 float （float 在渲染是计算了量比较大）
    不滥用 web 字体 (Web 字体需要下载，解析，重绘当前页面)
    合理使用 requestAnimationFrame 动画代替 setTimeout
    CSS 中的属性 (transitions, transforms3d, opacity, canvas, webgl, video) 会触发GPU渲染。请合理使用，过度使用会引发手机耗电增加



缓存利用：
    缓存 AJAX
    使用 CDN
    添加 Expires 头
    服务端配置 Etag
        什么是 Etag?
            当发送一个服务器请求是，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。
            情景一：
                如果没有过期，不会像服务端发送请求，直接使用缓存中的结果。(200 OK from cache) C/S 没有任何交互
            情景二：
                如果已过期，向服务器发送请求，请求会带上 "Last-Modified" 和 "Etag" 然后进行资源更新判断
                服务器根据传过来的文件修改时间(Last-Modified) 来判断浏览器上一次请求之后文件是否有修改过；
                根据 Etag 来判断文件内容自从上一次请求之后是否有变化。

                CASE1:
                    如果两种判断都是文件没有修改过，则服务器不会给浏览器发内容，直接告诉它文件没有被修改过，你用你那边的缓存吧 (304 Not Modified)
                    这种情况浏览器从本地缓存拿内容。这种情况叫协议缓存。C/S之间有一次请求交互

                CASE2:
                    如果两种判断中任何一种没有通过，则服务器会接受这次请求。
                    ```
                        Cache-Control: no-cache, private, max-age=0
                        ETag: abcde
                        Expires: Thu, 15 Apr 2014 20:00:00 GMT
                        Pragma: private
                        Last-Modified: $now // RFC1123 format
                    ```
                    Expires 要求客户端和服务端的时钟严格同步。
                    HTTP1.1 引入 Cache-Control 来克服 Expires 头的限制。
                    如果 max-age 和 Expires 同时出现，则 max-age 有更高的优先级。

                    **只有 get 请求会被缓存，post 请求不会**




    减少 DNS 查找



请求数量：
    合并样式脚本，使用 css 雪碧图、同样图标使用 icon font 代替图片等等。
    首屏之外的图片资源按需加载。
    静态资源延迟加载。

请求宽带：
    压缩文件 minify
    开启 GZIP

服务器


## 实现一个 `快速排序` `冒泡排序` ?

## ES6 一些新东西

## JS 继承方式及其优缺点
    - 原型链集成
        缺点：重写原型会中断关系，使用引用类型的原型，子类型无法给超类型传递参数
    - 构造函数继承（class 继承）
    - 组合继承

script:defer --> 并行加载 JS 文件，会按照页面上 script 顺序执行
script:async --> 并行加载 JS 文件，下载完成立即执行，不会安装页面上 script 顺序执行


## 说说你对闭包的理解
闭包主要是用在设计私有方法和变量。
    优点：可以避免全局变量的污染
    缺点：会常驻内存，会增加内存的使用量，使用不当很容易造成内存泄漏。
所以在JS中，函数就是闭包，只有函数才会产生作用域的概念。

特性：
    函数嵌函数（通常返回内部函数来当做该函数的返回结果）
        function tdd() {
            var sum = 0

            return function increment() {
                this.sum++
            }
        }
    函数内部可以引用外部的参数和变量。如上面的 sum 变量
    参数和变量不会被垃圾回收机制回收。(在函数外部有对 increment() 的引用，产生了闭包，sum 不会被回收)
